// ÂºïÂÖ•node.jsÁöÑpathÊ®°Âùó
const path = require('path')
// debugÂ∫ìÔºå‰∏Ä‰∏™Ê®°‰ªøNode.jsÊ†∏ÂøÉË∞ÉËØïÊäÄÊúØÁöÑÂ∞èÂûãJavaScriptË∞ÉËØïÂ∑•ÂÖ∑„ÄÇÂú®Node.jsÂíåwebÊµèËßàÂô®‰∏≠Â∑•‰Ωú
// Âú∞ÂùÄÔºöhttps://github.com/visionmedia/debug
const debug = require('debug')
// inquirerÔºå‰∏ÄÁªÑÂ∏∏Áî®ÁöÑ‰∫§‰∫íÂºèÂëΩ‰ª§Ë°åÁî®Êà∑ÁïåÈù¢„ÄÇÂú∞ÂùÄÔºöhttps://github.com/SBoudrias/Inquirer.js
const inquirer = require('inquirer')
// ÂºïÂÖ•node.jsÁöÑ‰∫ã‰ª∂Ëß¶ÂèëÂô®Ê®°Âùó
const EventEmitter = require('events')
// ÂºïÂÖ•Ê®°ÂùóÊñá‰ª∂
const Generator = require('./Generator')
// ÂºïÂÖ•lodashÁöÑÊ∑±Êã∑Ë¥ùÂáΩÊï∞
const cloneDeep = require('lodash.clonedeep')
// ÂØπÂØπË±°ËøõË°åÊéíÂ∫è
const sortObject = require('./util/sortObject')
// Ëé∑ÂèñÁâàÊú¨Âè∑
const getVersions = require('./util/getVersions')
// ÂåÖÁÆ°ÁêÜÂ∑•ÂÖ∑ÁöÑÊûÑÈÄ†ÂáΩÊï∞
const PackageManager = require('./util/ProjectPackageManager')
const { clearConsole } = require('./util/clearConsole')
// Ê≥®ÂÖ•prompts
const PromptModuleAPI = require('./PromptModuleAPI')
// ÁîüÊàêÊñá‰ª∂
const writeFileTree = require('./util/writeFileTree')
const { formatFeatures } = require('./util/features')
const loadLocalPreset = require('./util/loadLocalPreset')
const loadRemotePreset = require('./util/loadRemotePreset')
// ÁîüÊàêËá™Ëø∞Êñá‰ª∂README.md
const generateReadme = require('./util/generateReadme')
// Â∑•ÂÖ∑ÈõÜÂêàÔºåËØ¶ËßÅÂØπÂ∫îÁöÑ‰ª£Á†ÅËß£Êûê
const { resolvePkg, isOfficialPlugin } = require('@vue/cli-shared-utils')

const {
  defaults, // ÈªòËÆ§ÈÖçÁΩÆ
  saveOptions,
  loadOptions, // Âä†ËΩΩÂØπÂ∫îÁöÑÈÄâÈ°π
  savePreset,
  validatePreset,
  rcPath
} = require('./options')

const {
  chalk,
  execa,
  semver,

  log,
  warn,
  error,

  hasGit,
  hasProjectGit,
  hasYarn,
  hasPnpm3OrLater,
  hasPnpmVersionOrLater,

  exit,
  loadModule
} = require('@vue/cli-shared-utils')

// Âà§Êñ≠ÊòØ‰∏çÊòØÊâãÂä®Ê®°ÂºèÔºàËøô‰∏™Âú∞ÊñπÂ∫îËØ•Â∞±ÊòØÂàõÂª∫È°πÁõÆÁöÑÊó∂ÂÄôÂà§Êñ≠ÊòØÊâãÂä®ÈÄâÊã©Ê®°ÂùóËøòÊòØ‰ΩøÁî®ÈªòËÆ§ËÆæÁΩÆÊàñÊòØ‰∏äÊ¨°‰øùÂ≠òÁöÑÈÖçÁΩÆ‰ø°ÊÅØÔºâ
const isManualMode = answers => answers.preset === '__manual__'

module.exports = class Creator extends EventEmitter {
  // nameÔºöÈ°πÁõÆÂêç context: È°πÁõÆË∑ØÂæÑ promptModulesÔºöÂàõÂª∫È°πÁõÆÊó∂ÁöÑÈóÆÁ≠îÊ®°Âùó
  constructor (name, context, promptModules) {
    // Ë∞ÉÁî®super
    super()

    // È°πÁõÆÂêç
    this.name = name
    // È°πÁõÆË∑ØÂæÑ
    this.context = process.env.VUE_CLI_CONTEXT = context
    // Ëß£ÊûêÈóÆÁ≠îÈÄâÊã©ÈÖçÁΩÆ‰ø°ÊÅØ
    const { presetPrompt, featurePrompt } = this.resolveIntroPrompts()

    // ÈÖçÁΩÆ‰ø°ÊÅØ
    this.presetPrompt = presetPrompt
    // ÁâπÊÄßÂäüËÉΩ‰ø°ÊÅØ
    this.featurePrompt = featurePrompt
    // Ëß£ÊûêÈÄâÊã©ÂÆåÂäüËÉΩÁâπÊÄßËøáÂêéÁöÑÁõ∏ÂÖ≥ÈÄâÈ°π
    this.outroPrompts = this.resolveOutroPrompts()


    // ÁâπÊÄßÂäüËÉΩÂØπÂ∫îÁöÑÈÄâÈ°π
    this.injectedPrompts = []
    // ÂõûË∞ÉÂáΩÊï∞
    this.promptCompleteCbs = []

    // Ëøô‰∏™‰∏§‰∏™ÂèòÈáèÁöÑÂÄºÂú®GeneratorAPI.jsÈáåÈù¢ÁîüÊàê
    this.afterInvokeCbs = []
    this.afterAnyInvokeCbs = []

    this.run = this.run.bind(this)

    // ÊâßË°åÂ∞ÅË£ÖÂ•ΩÁöÑPromptModuleAPIÔºåÂ∞ÜÈÖçÁΩÆÂ•ΩÁöÑÁâπÊÄßÂíåÈÄâÈ°πÊ≥®ÂÖ•featurePrompt„ÄÅinjectedPrompts„ÄÅpromptCompleteCbsÔºå
    // ËØ¶ÁªÜ‰ª£Á†ÅÈÄªËæëËßÅPromptModuleAPI.js
    const promptAPI = new PromptModuleAPI(this)
    promptModules.forEach(m => m(promptAPI))
  }

  /***
   * ÂàõÂª∫È°πÁõÆ
   * @param { Object } cliOptions ÊâßË°åvue createÊó∂‰º†ÈÄíËøõÊù•ÁöÑÈÄâÈ°πÂèÇÊï∞
   * @param { Any } preset È¢ÑÁΩÆÈÄâÈ°π
   * @return { Promise } async‰øÆÈ•∞ËøáÂêéÁöÑÂáΩÊï∞ÔºåËøîÂõû‰∏Ä‰∏™PromiseÂØπË±° 
   * ***/
  async create (cliOptions = {}, preset = null) {
    // Âà§Êñ≠ÂΩìÂâçÊòØÂê¶ÊòØÊµãËØïÊàñÊòØË∞ÉËØïÊ®°Âºè
    const isTestOrDebug = process.env.VUE_CLI_TEST || process.env.VUE_CLI_DEBUG
    // Ëß£ÊûÑ
    const { run, name, context, afterInvokeCbs, afterAnyInvokeCbs } = this
    // Â¶ÇÊûúÊ≤°ÊúâÈªòËÆ§ÁöÑÈÖçÁΩÆ‰ø°ÊÅØ
    if (!preset) {
      // ÊâßË°åvue createÊó∂ÊâßË°å‰∫ÜÂèÇÊï∞--preset
      if (cliOptions.preset) {
        // vue create foo --preset bar
        // Âä†ËΩΩÈªòËÆ§ÈÖçÁΩÆ
        preset = await this.resolvePreset(cliOptions.preset, cliOptions.clone)
      } else if (cliOptions.default) {
        // vue create foo --default
        // Âä†ËΩΩÈªòËÆ§ÈÖçÁΩÆ
        preset = defaults.presets.default
      } else if (cliOptions.inlinePreset) {
        // vue create foo --inlinePreset {...}
        // ‰ΩøÁî®--inlinePresetÂëΩ‰ª§Ôºå‰º†ÂÖ•Ëá™ÂÆö‰πâÁöÑjsonÊ†ºÂºèÁöÑÈÖçÁΩÆ
        try {
          preset = JSON.parse(cliOptions.inlinePreset)
        } catch (e) {
          error(`CLI inline preset is not valid JSON: ${cliOptions.inlinePreset}`)
          exit(1)
        }
      } else {
        // ‰ª•‰∏äÊù°‰ª∂ÈÉΩ‰∏çÊª°Ë∂≥Êó∂ÔºåÊâßË°å‰ª•‰∏ãËß£ÊûêÊìç‰ΩúÔºåÈÄöËøápromptsËá™Ë°åÈÄâÊã©Áõ∏ÂÖ≥ÈÖçÁΩÆÁâπÊÄß
        preset = await this.promptAndResolvePreset()
      }
    }

    // ÈÄöËøáÊâãÂä®Ê®°ÂºèÈÄâÊã©ÁöÑpersetÂ§ßÊ¶ÇÈïøËøôÊ†∑
    // {
    //   useConfigFiles: true,
    //   plugins: {
    //     '@vue/cli-plugin-babel': {},
    //     '@vue/cli-plugin-typescript': { classComponent: false, useTsWithBabel: true },
    //     '@vue/cli-plugin-pwa': {},
    //     '@vue/cli-plugin-router': { historyMode: false },
    //     '@vue/cli-plugin-vuex': {},
    //     '@vue/cli-plugin-eslint': { config: 'prettier', lintOn: [Array] },
    //     '@vue/cli-plugin-unit-jest': {},
    //     '@vue/cli-plugin-e2e-cypress': {}
    //   },
    //   vueVersion: '2',
    //   cssPreprocessor: 'dart-sass'
    // }

    // clone before mutating
    preset = cloneDeep(preset)
    // inject core service
    preset.plugins['@vue/cli-service'] = Object.assign({
      projectName: name
    }, preset)

    // vue create proj --bare
    // Scaffold project without beginner instructions
    if (cliOptions.bare) {
      preset.plugins['@vue/cli-service'].bare = true
    }

    // legacy support for router
    if (preset.router) {
      preset.plugins['@vue/cli-plugin-router'] = {}

      if (preset.routerHistoryMode) {
        preset.plugins['@vue/cli-plugin-router'].historyMode = true
      }
    }

    // Introducing this hack because typescript plugin must be invoked after router.
    // Currently we rely on the `plugins` object enumeration order,
    // which depends on the order of the field initialization.
    // FIXME: Remove this ugly hack after the plugin ordering API settled down
    if (preset.plugins['@vue/cli-plugin-router'] && preset.plugins['@vue/cli-plugin-typescript']) {
      const tmp = preset.plugins['@vue/cli-plugin-typescript']
      delete preset.plugins['@vue/cli-plugin-typescript']
      preset.plugins['@vue/cli-plugin-typescript'] = tmp
    }

    // legacy support for vuex
    if (preset.vuex) {
      preset.plugins['@vue/cli-plugin-vuex'] = {}
    }

    // Á°ÆËÆ§ÂåÖÁÆ°ÁêÜÂ∑•ÂÖ∑
    const packageManager = (
      cliOptions.packageManager ||
      loadOptions().packageManager ||
      (hasYarn() ? 'yarn' : null) ||
      (hasPnpm3OrLater() ? 'pnpm' : 'npm')
    )
    
    await clearConsole()
    // ÂàõÂª∫‰∏Ä‰∏™ÂåÖÁÆ°ÁêÜÂÆû‰æã
    const pm = new PackageManager({ context, forcePackageManager: packageManager })

    log(`‚ú®  Creating project in ${chalk.yellow(context)}.`)
    // Ëøô‰∏™creation‰∫ã‰ª∂Âú®cli-uiÈáåÈù¢ÈúÄË¶ÅÁî®Âà∞Ôºå@vue\cli-ui\apollo-server\connectors\projects.js
    // Ëøô‰∏™Êñá‰ª∂ÈáåÈù¢Êúâ‰ª£Á†ÅÁõëÂê¨‰∫Ücreation‰∫ã‰ª∂ÔºåÈáåÈù¢‰πü‰ΩøÁî®‰∫ÜCreatorÊûÑÈÄ†ÂáΩÊï∞
    this.emit('creation', { event: 'creating' })

    // get latest CLI plugin version
    const { latestMinor } = await getVersions()

    // generate package.json with plugin dependencies
    // ÁîüÊàêpackage.jsonÂèÇÊï∞
    const pkg = {
      name,
      version: '0.1.0',
      private: true,
      devDependencies: {},
      ...resolvePkg(context) // Â¶ÇÊûúÁîüÊàêÈ°πÁõÆÁöÑÊñá‰ª∂Â§πÊèê‰æõ‰∫Üpackage.jsonÊñá‰ª∂Ôºå...resolvePkg(context)ËøôÂè•ËØùÊâçÊúâÂÆûÈôÖ‰ΩúÁî®
    }
    const deps = Object.keys(preset.plugins)
    // Â∞ÜcliÁõ∏ÂÖ≥ÁöÑÊèí‰ª∂Ê≥®ÂÖ•Âà∞package.jsonÁöÑdevDependencies
    deps.forEach(dep => {
      if (preset.plugins[dep]._isPreset) {
        return
      }

      let { version } = preset.plugins[dep]

      // Âà§ÂÆö@vue/cli-plugin-XXXÁ≥ªÂàóÊèí‰ª∂ÁöÑÁâàÊú¨
      if (!version) {
        if (isOfficialPlugin(dep) || dep === '@vue/cli-service' || dep === '@vue/babel-preset-env') {
          version = isTestOrDebug ? `file:${path.resolve(__dirname, '../../../', dep)}` : `~${latestMinor}`
        } else {
          version = 'latest'
        }
      }

      pkg.devDependencies[dep] = version
    })

    // write package.json
    await writeFileTree(context, {
      'package.json': JSON.stringify(pkg, null, 2)
    })

    // generate a .npmrc file for pnpm, to persist the `shamefully-flatten` flag
    if (packageManager === 'pnpm') {
      const pnpmConfig = hasPnpmVersionOrLater('4.0.0')
        ? 'shamefully-hoist=true\n'
        : 'shamefully-flatten=true\n'

      await writeFileTree(context, {
        '.npmrc': pnpmConfig
      })
    }

    if (packageManager === 'yarn' && semver.satisfies(process.version, '8.x')) {
      // Vue CLI 4.x should support Node 8.x,
      // but some dependenices already bumped `engines` field to Node 10
      // and Yarn treats `engines` field too strictly
      await writeFileTree(context, {
        '.yarnrc': '# Hotfix for Node 8.x\n--install.ignore-engines true\n'
      })
    }

    // intilaize git repository before installing deps
    // so that vue-cli-service can setup git hooks.
    const shouldInitGit = this.shouldInitGit(cliOptions)
    if (shouldInitGit) {
      log(`üóÉ  Initializing git repository...`)
      this.emit('creation', { event: 'git-init' })
      await run('git init')
    }

    // install plugins
    log(`‚öô\u{fe0f}  Installing CLI plugins. This might take a while...`)
    log()
    this.emit('creation', { event: 'plugins-install' })

    if (isTestOrDebug && !process.env.VUE_CLI_TEST_DO_INSTALL_PLUGIN) {
      // in development, avoid installation process
      await require('./util/setupDevProject')(context)
    } else {
      await pm.install()
    }

    // run generator
    log(`üöÄ  Invoking generators...`)
    this.emit('creation', { event: 'invoking-generators' })
    //   plugins: {
    //     '@vue/cli-plugin-babel': {},
    //     '@vue/cli-plugin-typescript': { classComponent: false, useTsWithBabel: true },
    //     '@vue/cli-plugin-pwa': {},
    //     '@vue/cli-plugin-router': { historyMode: false },
    //     '@vue/cli-plugin-vuex': {},
    //     '@vue/cli-plugin-eslint': { config: 'prettier', lintOn: [Array] },
    //     '@vue/cli-plugin-unit-jest': {},
    //     '@vue/cli-plugin-e2e-cypress': {}
    //   },
    const plugins = await this.resolvePlugins(preset.plugins, pkg)
    const generator = new Generator(context, {
      pkg,
      plugins,
      afterInvokeCbs,
      afterAnyInvokeCbs
    })
    await generator.generate({
      extractConfigFiles: preset.useConfigFiles
    })

    // install additional deps (injected by generators)
    log(`üì¶  Installing additional dependencies...`)
    this.emit('creation', { event: 'deps-install' })
    log()
    if (!isTestOrDebug || process.env.VUE_CLI_TEST_DO_INSTALL_PLUGIN) {
      await pm.install()
    }

    // run complete cbs if any (injected by generators)
    log(`‚öì  Running completion hooks...`)
    this.emit('creation', { event: 'completion-hooks' })
    for (const cb of afterInvokeCbs) {
      await cb()
    }
    for (const cb of afterAnyInvokeCbs) {
      await cb()
    }

    if (!generator.files['README.md']) {
      // generate README.md
      log()
      log('üìÑ  Generating README.md...')
      await writeFileTree(context, {
        'README.md': generateReadme(generator.pkg, packageManager)
      })
    }

    // commit initial state
    let gitCommitFailed = false
    if (shouldInitGit) {
      await run('git add -A')
      if (isTestOrDebug) {
        await run('git', ['config', 'user.name', 'test'])
        await run('git', ['config', 'user.email', 'test@test.com'])
        await run('git', ['config', 'commit.gpgSign', 'false'])
      }
      const msg = typeof cliOptions.git === 'string' ? cliOptions.git : 'init'
      try {
        await run('git', ['commit', '-m', msg, '--no-verify'])
      } catch (e) {
        gitCommitFailed = true
      }
    }

    // log instructions
    log()
    log(`üéâ  Successfully created project ${chalk.yellow(name)}.`)
    if (!cliOptions.skipGetStarted) {
      log(
        `üëâ  Get started with the following commands:\n\n` +
        (this.context === process.cwd() ? `` : chalk.cyan(` ${chalk.gray('$')} cd ${name}\n`)) +
        chalk.cyan(` ${chalk.gray('$')} ${packageManager === 'yarn' ? 'yarn serve' : packageManager === 'pnpm' ? 'pnpm run serve' : 'npm run serve'}`)
      )
    }
    log()
    this.emit('creation', { event: 'done' })

    if (gitCommitFailed) {
      warn(
        `Skipped git commit due to missing username and email in git config, or failed to sign commit.\n` +
        `You will need to perform the initial commit yourself.\n`
      )
    }

    generator.printExitLogs()
  }

  // ÊâßË°åÁõ∏ÂÖ≥ÁöÑÂëΩ‰ª§Ôºànpm gitÁöÑÁõ∏ÂÖ≥ÂëΩ‰ª§Ôºâ
  run (command, args) {
    if (!args) { [command, ...args] = command.split(/\s+/) }
    return execa(command, args, { cwd: this.context })
  }

  /***
   * ÈÄöËøápromptsÈÄâÊã©ÈÖçÁΩÆÈÄâÈ°π
   * ***/
  async promptAndResolvePreset (answers = null) {
    // prompt
    if (!answers) {
      // Ê∏ÖÁ©∫ÊéßÂà∂Âè∞
      await clearConsole(true)
      // Ëß£ÊûêÂá∫ÊâÄÊúâÁöÑÈÄâÈ°πÂπ∂Ê≥®ÂÖ•inquirer.prompt„ÄÇ
      answers = await inquirer.prompt(this.resolveFinalPrompts())
    }
    debug('vue-cli:answers')(answers)

    if (answers.packageManager) {
      saveOptions({
        packageManager: answers.packageManager
      })
    }

    let preset
    // ÈùûÊâãÂä®Ê®°Âºè
    if (answers.preset && answers.preset !== '__manual__') {
      preset = await this.resolvePreset(answers.preset)
    } else {
      // manual
      preset = {
        useConfigFiles: answers.useConfigFiles === 'files',
        plugins: {}
      }
      answers.features = answers.features || []
      // run cb registered by prompt modules to finalize the preset
      this.promptCompleteCbs.forEach(cb => cb(answers, preset))
    }

    // validate
    validatePreset(preset)

    // save preset
    if (answers.save && answers.saveName && savePreset(answers.saveName, preset)) {
      log()
      log(`üéâ  Preset ${chalk.yellow(answers.saveName)} saved in ${chalk.yellow(rcPath)}`)
    }

    debug('vue-cli:preset')(preset)
    return preset
  }

  /***
   * Ëß£ÊûêÈªòËÆ§ÈÖçÁΩÆ
   * @param { String } name È¢ÑÁΩÆÈÖçÁΩÆÁöÑÂêçÂ≠ó
   * @param { String } clone ÊòØÂê¶‰ΩøÁî®‰∫ÜÂÖãÈöÜÂëΩ‰ª§
   * @return { Object } ËøîÂõûÈÖçÁΩÆ‰ø°ÊÅØ
   * ***/
  async resolvePreset (name, clone) {
    let preset
    // Âä†ËΩΩÊú¨Âú∞‰øùÂ≠òÁöÑÈªòËÆ§ÈÖçÁΩÆ
    const savedPresets = this.getPresets()

    // Â¶ÇÊûú‰º†ÂÖ•ÁöÑÈ¢ÑÁΩÆÈÖçÁΩÆÂú®Êú¨Âú∞ÁöÑÈÖçÁΩÆÈáåÈù¢ÊúâÔºåÂàôÂèñÊú¨Âú∞ÁöÑ
    if (name in savedPresets) {
      preset = savedPresets[name]
    } 
    // path.isAbsolute() ÊñπÊ≥ïÊ£ÄÊµã path ÊòØÂê¶‰∏∫ÁªùÂØπË∑ØÂæÑ„ÄÇ
    // ËøôÈÉ®ÂàÜË°®Á§∫‰Ω†Âú®‰ΩøÁî®vue createÂëΩ‰ª§Êó∂Âú®ÂêéÈù¢Ë∑ü‰∫ÜÂèÇÊï∞--preset Êñá‰ª∂ÂêçÔºåË°®Á§∫‰Ω†Ëá™Â∑±Êèê‰æõÈÖçÁΩÆ‰ø°ÊÅØ
    // Ëøô‰∏™È¢ÑÁΩÆÈÖçÁΩÆÁöÑÊñá‰ª∂ÊîæÂú®‰Ω†Ë¶ÅÁîüÊàêÈ°πÁõÆÁöÑÁõÆÂΩï‰∏ãÈù¢„ÄÇ
    else if (name.endsWith('.json') || /^\./.test(name) || path.isAbsolute(name)) {
      preset = await loadLocalPreset(path.resolve(name))
    } 
    // Êèê‰æõÁöÑÈ¢ÑÁΩÆÈÖçÁΩÆ‰∏∫‰∏Ä‰∏™ËøûÊé•
    else if (name.includes('/')) {
      log(`Fetching remote preset ${chalk.cyan(name)}...`)
      this.emit('creation', { event: 'fetch-remote-preset' })
      try {
        // Âä†ËΩΩËøúÁ®ãÁöÑÈ¢ÑÁΩÆÈÖçÁΩÆ
        preset = await loadRemotePreset(name, clone)
      } catch (e) {
        error(`Failed fetching remote preset ${chalk.cyan(name)}:`)
        throw e
      }
    }

    if (!preset) {
      error(`preset "${name}" not found.`)
      const presets = Object.keys(savedPresets)
      if (presets.length) {
        log()
        log(`available presets:\n${presets.join(`\n`)}`)
      } else {
        log(`you don't seem to have any saved preset.`)
        log(`run vue-cli in manual mode to create a preset.`)
      }
      exit(1)
    }
    return preset
  }

  // { id: options } => [{ id, apply, options }]
  /***
   * Ëß£ÊûêÊèí‰ª∂
   * @param { Object } rawPlugins ÈÄâÊã©ÁöÑÊèí‰ª∂ÂàóË°®
   * @param { Object } pkg package.json‰ø°ÊÅØ
   * @return { Array } ËøîÂõûËß£ÊûêËøáÂêéÁöÑÊï∞ÁªÑ
   * ***/
  async resolvePlugins (rawPlugins, pkg) {
    // ensure cli-service is invoked first
    // ÂØπÂØπË±°ËøõË°åÊéíÂ∫è
    rawPlugins = sortObject(rawPlugins, ['@vue/cli-service'], true)
    const plugins = []
    for (const id of Object.keys(rawPlugins)) {
      const apply = loadModule(`${id}/generator`, this.context) || (() => {})
      let options = rawPlugins[id] || {}

      if (options.prompts) {
        let pluginPrompts = loadModule(`${id}/prompts`, this.context)

        if (pluginPrompts) {
          const prompt = inquirer.createPromptModule()

          if (typeof pluginPrompts === 'function') {
            pluginPrompts = pluginPrompts(pkg, prompt)
          }
          if (typeof pluginPrompts.getPrompts === 'function') {
            pluginPrompts = pluginPrompts.getPrompts(pkg, prompt)
          }

          log()
          log(`${chalk.cyan(options._isPreset ? `Preset options:` : id)}`)
          options = await prompt(pluginPrompts)
        }
      }

      plugins.push({ id, apply, options })
    }
    return plugins
  }
  /***
   * Ëé∑ÂèñÈ¢ÑÁΩÆÈÄâÈ°π
   * @return { Object } ËøîÂõûÂØπÂ∫îÁöÑÈ¢ÑÁΩÆÈÄâÈ°π
   * ***/
  getPresets () {
    // Âä†ËΩΩÂØπÂ∫îÁöÑÂàõÂª∫È°πÁõÆÊó∂ÁöÑÈÄâÈ°π
    /***
     * loadOptionsÂä†ËΩΩÊú¨Âú∞.vuercÊñá‰ª∂ÁöÑÂÜÖÂÆπÔºåÂ§ßÊ¶ÇÈïøËøôÊ†∑
     * {
        "useTaobaoRegistry": true,
        "latestVersion": "4.5.12",
        "lastChecked": 1616988092123,
        "packageManager": "npm",
        "presets": {
          "mine-default": {
            "useConfigFiles": true,
            "plugins": {
              "@vue/cli-plugin-babel": {},
              "@vue/cli-plugin-router": { "historyMode": false },
              "@vue/cli-plugin-vuex": {},
              "@vue/cli-plugin-eslint": {
                "config": "prettier",
                "lintOn": ["save", "commit"]
              }
            },
            "vueVersion": "2",
            "cssPreprocessor": "dart-sass"
          }
        }
      }
     * ***/
    const savedOptions = loadOptions()

    // ËøîÂõû‰Ω†Êú¨Âú∞‰øùÂ≠òÁöÑÈÖçÁΩÆ‰ª•ÂèäcliËÑöÊâãÊû∂Ëá™Â∏¶ÁöÑÈÖçÁΩÆ
    return Object.assign({}, savedOptions.presets, defaults.presets)
  }

  /***
   * Ëß£ÊûêÁ¨¨‰∏ÄÊ≠•ÁöÑÈÄâÈ°πÔºàÈ¢ÑÁΩÆÈÖçÁΩÆÔºâ
   * @return { Object } ËøîÂõûÂØπÂ∫îÁöÑÈÖçÁΩÆ‰ø°ÊÅØÔºàÊØîÂ¶Ç‰Ω†ÁöÑÈ¢ÑÁΩÆÈÖçÁΩÆ„ÄÅvue2„ÄÅvue3ÊàñËÄÖÊòØManually select featuresÔºâ
   * ***/
  resolveIntroPrompts () {
    // Ëé∑ÂèñÂà∞ÂØπÂ∫îÁöÑÈÄâÈ°π
    // Ëøô‰∏™ÊñπÊ≥ï‰∏ªË¶ÅÊòØ‰ºöÂéªÂèñ.vuercÈáåÈù¢‰øùÂ≠òÁöÑ‰∏äÊ¨°Â≠òÂÇ®ÁöÑÈÖçÁΩÆ‰ø°ÊÅØ
    /***
     * persetsÂØπË±°Â§ßÊ¶ÇÈïøËøôÊ†∑
     * {
        "mine-default": {
          "useConfigFiles": true,
          "plugins": {
            "@vue/cli-plugin-babel": {},
            "@vue/cli-plugin-router": { "historyMode": false },
            "@vue/cli-plugin-vuex": {},
            "@vue/cli-plugin-eslint": {
              "config": "prettier",
              "lintOn": ["save", "commit"]
            }
          },
          "vueVersion": "2",
          "cssPreprocessor": "dart-sass"
        },
        "default": {
          "useConfigFiles": false,
          "plugins": {
            "@vue/cli-plugin-babel": {},
            "@vue/cli-plugin-eslint": {
              "config": "base",
              "lintOn": "['save']"
            }
          },
          "vueVersion": "2",
          "cssPreprocessor": "undefined"
        },
        "__default_vue_3__": {
          "useConfigFiles": false,
          "plugins": {
            "@vue/cli-plugin-babel": {},
            "@vue/cli-plugin-eslint": {
              "config": "base",
              "lintOn": "['save']"
            }
          },
          "vueVersion": "3",
          "cssPreprocessor": "undefined"
        }
      }
     * ***/
    const presets = this.getPresets()


    // Object.entries()ÊñπÊ≥ïËøîÂõû‰∏Ä‰∏™ÁªôÂÆöÂØπË±°Ëá™Ë∫´ÂèØÊûö‰∏æÂ±ûÊÄßÁöÑÈîÆÂÄºÂØπÊï∞ÁªÑÔºå
    // ÂÖ∂ÊéíÂàó‰∏é‰ΩøÁî® for...in Âæ™ÁéØÈÅçÂéÜËØ•ÂØπË±°Êó∂ËøîÂõûÁöÑÈ°∫Â∫è‰∏ÄËá¥ÔºàÂå∫Âà´Âú®‰∫é for-in Âæ™ÁéØËøò‰ºöÊûö‰∏æÂéüÂûãÈìæ‰∏≠ÁöÑÂ±ûÊÄßÔºâ„ÄÇ
    // Object.entries({a: 100, b: 'hello'})
    // ËæìÂá∫Ôºö[['a', 100], ['b', 'hello']]
    const presetChoices = Object.entries(presets).map(([name, preset]) => {
      let displayName = name
      // Âå∫Âà´Âà§Êñ≠ÊòØÈÄâÊã©ÁöÑvue2ËøòÊòØvue3
      if (name === 'default') {
        displayName = 'Default'
      } else if (name === '__default_vue_3__') {
        displayName = 'Default (Vue 3 Preview)'
      }
      
      // formatFeaturesËøô‰∏™ÊñπÊ≥ï‰ºöÊää‰Ω†ÈÄâÊã©ÁöÑÂäüËÉΩÁâπÊÄßËΩ¨Êç¢‰∏∫‰∏ÄÂè•ËØùÔºå
      // ÊØîÂ¶ÇËøôÁßç hash-mode ([Vue 2] dart-sass, babel, router, vuex, eslint)
      return {
        name: `${displayName} (${formatFeatures(preset)})`,
        value: name
      }
    })
    // Ê∂àÊÅØÊèêÁ§∫-ÈÄâÊã©‰Ω†ÂØπÂ∫îÁöÑÈÖçÁΩÆÔºåËøô‰∏™ÂØπË±°‰øùÂ≠ò‰∫ÜÂØπÂ∫îÁöÑÈÖçÁΩÆ‰ø°ÊÅØÔºå‰πüÂ∞±ÊòØÊàë‰ª¨ÊâßË°åvue create projname
    // ÊòæÁ§∫ÁöÑ‰∏ÄË°åË°åÈÄâÊã©ÔºåÂ§ßÊ¶ÇÈïø‰∏ãÈù¢ËøôÊ†∑
    // history-mode ([Vue 2] dart-sass, babel, router, vuex, eslint)
    // hash-mode ([Vue 2] dart-sass, babel, router, vuex, eslint)
    // Default ([Vue 2] babel, eslint)
    // Default (Vue 3 Preview) ([Vue 3] babel, eslint)
    // Manually select features
    const presetPrompt = {
      name: 'preset',
      type: 'list',
      message: `Please pick a preset:`,
      choices: [
        ...presetChoices,
        {
          name: 'Manually select features',
          value: '__manual__'
        }
      ]
    }
    // ÈÄâÊã©ÂØπÂ∫îÁöÑÊ®°ÂùóÁöÑÊó∂ÂÄôÁöÑÊèêÁ§∫Ê∂àÊÅØ
    // Êàë‰ª¨ÈÄâÊã©‰∫ÜÂØπÂ∫îÁöÑÈÖçÁΩÆÂêéÔºå‰πãÂêé‰ºöËÆ©‰Ω†ÈÄâÊã©ÂØπÂ∫îÁöÑÂäüËÉΩÔºåÊØîÂ¶Çbabel„ÄÅts„ÄÅvuex„ÄÅrouterËøô‰∫õ‰∏úË•ø
    // ? Check the features needed for your project: (Press <space> to select, <a> to toggle all, <i> to invert selection)
    const featurePrompt = {
      name: 'features',
      when: isManualMode,
      type: 'checkbox',
      message: 'Check the features needed for your project:',
      choices: [],
      pageSize: 10
    }
    return {
      // Á¨¨‰∏ÄÊ≠•ÂØπÂ∫îÁöÑÈÖçÁΩÆÈõÜÂêà
      presetPrompt,
      // Á¨¨‰∫åÊ≠•ÈÄâÊã©ÂäüËÉΩÊó∂ÁöÑÂâçÁΩÆ‰ø°ÊÅØ
      featurePrompt
    }
  }
  /***
   * Âú®ÈÄâÊã©ÂÆåÁâπÊÄßÂäüËÉΩÂêéÔºåÂØπÂ∫îÁöÑÂÖ∂‰ªñÈÄâÊã©Ôºå‰ªéWhere do you prefer placing config for Babel, ESLint, etc.?
   * Ëøô‰∏™Ê∂àÊÅØËøáÂêéÁöÑÁõ∏ÂÖ≥ÁöÑÈÄâÊã©ÊèêÁ§∫Ôºå
   * ***/
  resolveOutroPrompts () {
    const outroPrompts = [
      {
        name: 'useConfigFiles',
        when: isManualMode,
        type: 'list',
        message: 'Where do you prefer placing config for Babel, ESLint, etc.?',
        choices: [
          {
            name: 'In dedicated config files',
            value: 'files'
          },
          {
            name: 'In package.json',
            value: 'pkg'
          }
        ]
      },
      {
        name: 'save',
        when: isManualMode,
        type: 'confirm',
        message: 'Save this as a preset for future projects?',
        default: false
      },
      {
        name: 'saveName',
        when: answers => answers.save,
        type: 'input',
        message: 'Save preset as:'
      }
    ]

    // ask for packageManager once
    const savedOptions = loadOptions()
    // ËøôÂêéÈù¢ÁöÑÊìç‰ΩúÂØπÂ∫îÁöÑÊòØ‰Ω†ÁöÑÈÄâÈ°πÈÖçÁΩÆÁöÑÂåÖÁÆ°ÁêÜÂ∑•ÂÖ∑Á±ªÂûã
    if (!savedOptions.packageManager && (hasYarn() || hasPnpm3OrLater())) {
      const packageManagerChoices = []

      // yarn
      if (hasYarn()) {
        packageManagerChoices.push({
          name: 'Use Yarn',
          value: 'yarn',
          short: 'Yarn'
        })
      }
      // pnpm
      if (hasPnpm3OrLater()) {
        packageManagerChoices.push({
          name: 'Use PNPM',
          value: 'pnpm',
          short: 'PNPM'
        })
      }
      // ÈªòËÆ§‰ΩøÁî®npm
      packageManagerChoices.push({
        name: 'Use NPM',
        value: 'npm',
        short: 'NPM'
      })

      outroPrompts.push({
        name: 'packageManager',
        type: 'list',
        message: 'Pick the package manager to use when installing dependencies:',
        choices: packageManagerChoices
      })
    }

    return outroPrompts
  }
  /***
   * Ëß£ÊûêÁî®Êà∑ÊúÄÁªàÈÄâÊã©ÁöÑÈÄâÈ°πÔºàÊúÄÁªàÁöÑÊâÄÊúâÈÄâÈ°πÔºâ
   * ***/
  resolveFinalPrompts () {
    // patch generator-injected prompts to only show in manual mode
    this.injectedPrompts.forEach(prompt => {
      const originalWhen = prompt.when || (() => true)
      prompt.when = answers => {
        return isManualMode(answers) && originalWhen(answers)
      }
    })

    const prompts = [
      this.presetPrompt,
      this.featurePrompt,
      ...this.injectedPrompts,
      ...this.outroPrompts
    ]
    debug('vue-cli:prompts')(prompts)
    return prompts
  }

  /***
   * ÊòØÂê¶ÂàùÂßãÂåñgit
   * @param { Object } cliOptions commanderÂëΩ‰ª§ÈÄâÈ°π
   * @return { Boolean } true | false
   * ***/
  shouldInitGit (cliOptions) {
    // ÊòØÂê¶ÂÆâË£Ö‰∫Ügit
    if (!hasGit()) {
      return false
    }
    // --git
    if (cliOptions.forceGit) {
      return true
    }
    // --no-git
    if (cliOptions.git === false || cliOptions.git === 'false') {
      return false
    }
    // default: true unless already in a git repo
    // Âà§Êñ≠È°πÁõÆ‰∏ãÊòØÂê¶ÂåÖÂê´.git
    return !hasProjectGit(this.context)
  }
}
